<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;
using HyperMapper.Internal;

namespace HyperMapper.Mappers
{
<# for(var i = 1; i <= 8; i++) { 
    Func<int, string> toT = x => "T" + ((x == 8) ? "Rest" : x.ToString());
    Func<int, string> toItem = x => ((x == 8) ? "Rest" : "Item" + x);
    var ts = string.Join(", ", Enumerable.Range(1, i).Select(x => toT(x))); 
    var t = "Tuple<" + ts + ">"; 
#>
    public sealed class TupleMapper<<#= ts #>> : IObjectMapper<<#= t #>, <#= t #>>
    {
        public <#= t #> Map(<#= t #> from, IObjectMapperResolver resolver)
        {
            if (from == null) return null;

            return new Tuple<<#= ts #>>(<#= string.Join(", ", Enumerable.Range(1, i).Select(x => "from." + toItem(x))) #>);
        }
    }

<# } #>

<# for(var i = 1; i <= 8; i++) { 
    Func<int, string> toT = x => "T" + ((x == 8) ? "Rest" : x.ToString());
    Func<int, string> toItem = x => ((x == 8) ? "Rest" : "Item" + x);
    var ts = string.Join(", ", Enumerable.Range(1, i).Select(x => toT(x))); 
    var t = "ValueTuple<" + ts + ">"; 
#>
    public sealed class ValueTupleMapper<<#= ts #>> : IObjectMapper<<#= t #>, <#= t #>><#= (t.Contains("TRest") ? " where TRest : struct" : "") #>
    {
        public <#= t #> Map(<#= t #> from, IObjectMapperResolver resolver)
        {
            return new ValueTuple<<#= ts #>>(<#= string.Join(", ", Enumerable.Range(1, i).Select(x => "from." + toItem(x))) #>);
        }
    }

<# } #>
}